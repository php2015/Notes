第2章 HTML 性能优化
<!-- 1. 内联和外部文件引入 -->
    <style>
        /*
        内联
            优点：
                减少HTTP请求
            缺点：
                1.没办法复用
                2.使得HTML文件变大，加载时间变长
                3.代码都写到HTML文件中，不利于后期的维护？
                    工程化的手段可以解决这个问题 (可以写在外面 帮我们内联进来)
                        源码到可以上线的代码
        */
    </style>

    <!--
        通过外部文件引入
            优点：
                1.很好的复用代码
                    有效利用浏览器的静态资源缓存
                2.代码分离，利于后期维护
            缺点：
                增加了HTTP请求
    -->
    建议：内联首屏必备的CSS 和 JS     
    CSS 放在页面前面  JS放在后面 !!
    和DOM无关的JS 或者 和屏幕适配要尽早加载的JS 也可以放在前面

            <!-- 2.避免重复的资源请求  
        文件压缩  
        合并CSS JS文件 (但是也要注意大小)      通过工具
        缓存(后端的活)    

            <!-- 2.2 图片和其他优化
<!-- 
        大、多
            HTTP请求大
                图片压缩处理
                使用更高压缩比格式的图片
                    webp
                尽量少用图片
                    使用图标字体代替图片图标 !!
                    CSS画图
            HTTP请求多
                合理使用base64内嵌图片 !!
                合并静态资源图片 !!
                    雪碧图  !!
    -->
    <!-- 减少DOM元素的嵌套层级 -->
    <!-- 避免空连接href、src -->
    <!-- 尽量避免使用table/iframe等慢元素 -->   //浏览器渲染慢 要把所有table读完再渲染出来
    <!-- 主要内容和次要内容的位置 -->


            <!-- 3.1 CSS选择器优化

        /*不要使用类选择器和ID选择器修饰元素标签，这样多此一举，还会降低效率。*/
        /*保持简单，不要使用嵌套过多过于复杂的选择器*/  推荐3个  
        /*浏览器从右向左解析CSS*/   
            /*嵌套少*/
            /*权重低 便于使用的时候覆盖*/

        /*避免通配选择器*/ css result的时候要给那些元素设置默认样式 就写那些就OK了

        /*避免类正则的属性选择器*/  高级的属性选择器 建议少用

        /*提取公用部分*/ 合并用简写属性

        /*避免使用CSS @import引用加载CSS*/

        /*使用CSS3动画，代替DOM动画*/   !

        /*优先考虑flex 不滥用float*/    !




            <!-- 4.1 DOM操作优化

<!--
        总结
            DOM操作很奢侈，很耗性能

                加快单次DOM操作  
                ( 尽量使用id选择器  合理使用选择器层级)

                减少DOM操作的次数
                合理缓存DOM对象/操作  cloneNode(true);   //复制节点  带true  复制内容

                缓存 DOM.length   
                每次.length都要计算，用一个变量保存这个值

                使用DocumentFragment优化多次的appendChild

                使用一次innerHTML

                不要直接修改style，通过添加class修改  
                (在最终渲染的时候 浏览器会重排 然后重绘  重排：计算元素位置  重绘：计算样式)
    -->


            <!-- 4.2 事件优化

        // 使用事件代理，避免直接事件绑定

        // 事件节流       如下高频事件可以使用定时器
        // scroll resize mousemove touchmove  

        资源的按需加载 看源码  (懒加载)
        1.通过额外的类名 把需要预加载的资源获取到数组    
        2.滚动条的时候添加事件 比如把资源加载出来                
        3.判断数组中的元素是否滚动到了可视区域     ( getBoundingClientRect() 方法返回元素在视口中的位置)
        4.到了就把资源加载出来 比如把src换成真的src  然后记得把加载完成的资源在数组中删除 splice()  然后如果是循环 索引还要减去一


        预加载







