 #HTTP/0.9

 只有一个命令get ，   没有Header ,   服务器发送完毕就关闭TCP连接

 #HTTP/1.0or1.1

 增加了很多命令，   增加了status code 和 header

 持久连接 ，   pipeline ,   增加host

 #HTTP/2

 所有数据以二进制传输

 同一个连接发送多个请求不再需要按顺序来

 头信息压缩以及推送等提高效率的功能（请求html同时 推送js，css到客户端  并行下载html，css，js）


 #应用层协议：

 只要能够保证，一端发送时构造的数据，另一端能够正确的解析，就是ok的，这种约定就是应用层协议

1. 认识URL

! [URL结构](./images/认识URL.png)

2. HTTP协议格式

（1）HTTP请求

主要分为四部分：

    1）请求行：在HTTP请求报文中第一行即为请求行，以空格为界，分为三个区域：【请求方法，常为GET/POST】+【想请求的资源url】+【HTTP协议版本，常为1.0/1.1】；

    2）请求报头Header：在HTTP请求报文中从第二行到空行之前的即为请求报头，是请求属性，均以冒号分割的键值对形式呈现，每组属性间用 \n 分隔；

    3）空行：表示报头已完，不能省略

    4）请求正文Body：空行以后的均是请求正文，表示要提交给浏览器看的消息，允许为空字符串。若Body存在，在Header中有一个Content-Length属性来表标识Body的长度；若服务器返回一个html页面，那么html页面内容就是在Body中

其中：

    1）GET方法：请求消息在正文中

    2）POST方法：请求消息在报文中

主要格式如下图：

! [HTTP协议格式](./images/HTTP协议格式.png)

（2）响应报文

主要分四部分：

    1）响应行：在HTTP请求报文中第一行即为请求行，以空格为界，分为三个区域：【协议版本号】+【状态码】+【状态码解释】；

    2）响应报头Header：在HTTP请求报文中从第二行到空行之前的即为请求报头，表示请求的属性；

    3）空行：表示报头已完，不能省略；

    4）响应正文Body：空行以后的均是请求正文，允许为空字符串；若Body存在，在Header中有一个Content-Length属性来表标识Body的长度；若服务器返回一个html页面，那么html页面内容就是在Body中。

具体响应报文如下图（其中一部分，响应正文没有截完）：

! [响应报文](./images/响应报文.png)

3. HTTP的方法

具体方法见下表，常用方法有GET与POST方法：

! [HTTP的方法](./images/HTTP的方法.png)

4. HTTP的状态码

HTTP的状态码有以下几种，其中重定向状态码又分为永久性重定向、临时性重定向两种。

! [HTTP的状态码](./images/HTTP的状态码.png)

5. HTTP常见Header（报头）

（1）Content-Type：数据类型（text/html等）

（2）Content-Length：请求正文的长度（字节为单位）

（3）Host：客户端告知服务器，所请求的资源是在哪台主机的哪个端口上

（4）User-Agent：声明用户的操作系统和浏览器版本信息

（5）referer：表明当前页面是从哪个页面跳转过来的

（6）location：跳转重定向，告诉客户端接下来要去哪访问，要搭配状态码3xx使用

（7）Cookie：是一个本地文件，用于在客户端存储少量信息，通常用于实现会话的功能。比如，在登录某个账号以及密码时，计算机允许在信息输入后，保存到本地上，以实现下次不用输入，这些信息会在，这样产生的文件就叫做Cookie。但是Cookie有安全隐患，因为保存的信息当中可能会有密码等。

Cookie的具体工作原理为：当用户访问某个带Cookie的网站时，该网站的服务器该用户产生一个标识符，并将该标识符作为索引在后台的数据库中生成一个项目。然后在响应报文中添加一个“Set-Cookie：标识符”的键值对。当浏览器收到响应之后，会将“服务器的主机名和标识符”添加在它管理的Cookie文件中。当用户继续浏览该网站时，浏览器会将在请求报文中添加“Cookie:标识符”的键值对，发送给服务器，这样服务器便可以根据标识符知道用户之前的活动状态了。

